## 一、树的基本概念

### 1.树的基本术语
- （1）结点的度和树的度
- （2）分支节点和叶子结点
- （3）路径和路径长度（通过的结点数-1）
- （4）孩子结点、双亲结点、兄弟结点、子孙结点和祖先结点
- （5）结点层次和树的高度
- （6）有序树和无序树
- （7）森林

### 2.树的性质
- （1）树中的结点数 = 所有节点的度数 + 1？
```C++
/*树结构常用于表示具有层次关系的数据
有且只有一个节点没有前驱节点，其余每个节点
只有一个前驱节点，但可以有零个或多个后继节点*/
 
/*树的逻辑表示方法：树形表示法、文氏图表示法等
 
树的基本术语 
1.节点的度和树的度；
2.分支节点与叶子节点；
3.路径与路径长度；
4.孩子节点、双亲节点、和兄弟节点；
5.节点层次（level),节点深度（depth），一个节点所在的层数为其双亲节点的层次加1。
树中节点的最大层次称为树的高度（height of tree）或树的深度（depth of tree）
6.有序树和无序树，一般都是有序树。
7.森林与树的转换*/ 

/*树的性质：
1.树中的结点数等于所有节点的度数之和加1
2.度为m的树中第i层上最多有m^i-1个结点（i>=1）。
3.高度为h的m次树最多有m^h-1/m-1个节点
4.具有n个结点的m次树的最小高度为[logm(n(m-1)+1)]*/

/*树的运算主要分为3大类
1.寻找满足某种特定条件的节点，如寻找当前节点的双亲节点
2.插入或删除某个节点，如在树的某个节点插入一个孩子节点或删除指定节点的第i个孩子节点等。
3.遍历（traversal）树中的所有节点，主要有：先根遍历、后根遍历很层次遍历3种。树的先根遍历和后根遍历都是递归的。
	先根遍历（preoder traversal):
		1.访问根节点
		2.按照从左到右的顺序先根遍历根节点的每一颗子树。
	后根遍历（postorder traversal)：
		1.按照从左到右的顺序后根遍历根节点的每一颗子树。
		2.访问根节点
	层次遍历（level traversal）的过程是从根节点开始按从上到下、从左到右的次序访问树中的每一个节点。*/
	
/*树的存储结构
存储树的基本结构既要存储节点的数据元素本身，又要存储节点之间的逻辑关系。

1.双亲存储结构（parent storage structure）是一种顺序存储结构，用一组连续空间存储树的所有节点，
同时在每个双亲节点中附设一个伪指针指示其双亲节点的位置（因为除了根节点以外，每个节点只有唯
一的双亲节点，将根节点的双亲位置设置为特殊值-1 */
#include"stdafx.h"
#define MaxSize 100
typedef int ElemType;
typedef struct
{
	ElemType data;  //存放结点的值 
	int parent;  // 存放双亲的位置 
} PTree[MaxSize];  // PTree 为双亲存储结构类型 

/*该存储结构利用了每个节点（根节点除外）只有唯一双亲节点的性质。
在这种存储结构中求某个结点的双亲节点十分容易，但在求某个节点的孩子结点是需要遍历整个存储结构。*/ 


/*
2.在孩子链存储结构（child chain storage structure）中，每个结点不仅包括结点值，还包括指向所有孩子节点的指针。
该算法可按树的度（即树中所有结点度的最大值）设计节点的孩子节点的指针域个数。

Z:也就是说按照最大的度来设计空间，比如:如果树的度为4，那么每个存储孩子节点的空间都为上4
*/ 
typedef struct node
{
	ElemType data;  // 结点的值 
	struct node * sons[MaxSize];  // 指向孩子节点 
}TsonNode;  // 孩子链式存储结构中的节点类型。
 /*优点：查找某结点的孩子节点十分方便
 缺点：查找某结点的双亲节点比较费时 or 当树的度较大时存在较多的空指针域。*/ 
 
 
 /*3.孩子兄弟链存储结构（child brother chain storage structure)为每个节点设计三个域
 一个数据元素域，一个指向该结点的左边第一个孩子节点（长子）的指针域，一个指向该结点的下一个兄弟节点的指针域*/ 
 typedef struct tnode
 {
 	ElemType data;
 	struct tnode * hp;
 	struct tnode * np;
 }TSBNode;
 /*这个存储结构有两个固定的指针域 and 这两个指针域是有序的，so 这个存储结构实际上是把树转换为了二叉树的存储结构
 优点：方便树与二叉树的互相转换
 缺点:从当前节点查找双亲节点比较麻烦，需要从书的根节点开始逐个节点比较查找*/

```


## 二、二叉树的概念和性质
```C++
// 一 
/*二叉树（binary tree）是一个有限的结点集合，这个集合或者为空，或者由一个根节点的两颗
互不相交的称为左子树（left subtree）和右子树（right subtree）的二叉树组成

二叉树结构简单、存储效率高，其运行算法也相对简单，而且任何m次树都可以转化为一个二叉树结构，差别在于：
	·度为2的树至少有一个节点的度为2，而二叉树没有这种要求；
	·度为2的树不分左右子树，而二叉树要严格区分。
	
二叉树的五种形态：
	·空二叉树
	·单个结点的二叉树
	·右子树为空的二叉树
	·左子树为空的二叉树
	·左、右子树都不为空的二叉树 
	
满二叉树（full binary tree）：在二叉树中，所有分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层
用户可以对满二叉树进行层次编号（level coding）
非空二叉树的特点：
	·叶子结点都在最下一层
	·只有度为0和度为2的节点

完全二叉树（complete binary tree):二叉树最多只有最下面两层的结点的度数可以小于2，
并且最下面一层的结点都依次排列在该层最左边的位置上

满二叉树是完全二叉树的一种特例

非空完全二叉树的特点：
	·叶子结点只可能在最下面两层中出现
	·对于最大层次中的叶子结点，都依次排列在该层最左边的位置上
	·如果有度为1的结点，只可能有一个，且该结点只有左孩子而无右孩子
	·按层序编号时，一旦出现编号为i的结点是叶子结点或只有左孩子，则编号大于i的结点均为叶子结点
	·当结点总数n为add时，n1=0，当叶子结点n为even时，n1=1；*/ 
	
```
### 2.1 二叉树的定义

#### 二叉树
- **二叉树** (binary tree) 是一个有限的结点集合，这个集合或者为空，或者由一个根节点的两个互不相交的称为左子树(left subtree)和右子树(right subtree)的二叉树组成

- 优点：二叉树结构简单、存储效率高，其运算算法也相对简单，而且任何m次树都可以转化为二叉树结构，因此二叉树具有很重要的地位。

- 二叉树和度为2的数（2次树）的不同：
    - 度为2的树中至少有一个节点的度为2，而二叉树没有这种要求；
    - 度为2的树不区分左、右字数，而二叉树是严格区分左、右子树的；

#### 满二叉树
- **满二叉树**(full binary tree): 在一课二叉树中，如果所有分支节点都有左孩子结点和右孩子结点，并且叶子结点都集中在二叉树的最下一层，这样的二叉树称为满二叉树。
- 用户可以对满二叉树进行层序编号(level coding)
- 从结点个数和树高度之间的关系来定义：一颗高度为h且有2<sup>h</sup>-1个结点的二叉树称为满二叉树
- 非空满二叉树的特点：
    - 叶子结点都在最下一层
    - 只有度为0和度为2的阶段

#### 完全二叉树
- **完全二叉树**(complete binary tree)若二叉树中最多只有最下面两层的结点的度数可以小于2，并且最下面一层的叶子结点都依次排列在该层最左边的位置上。则这样的二叉树称为完全二叉树
- 满二叉树是完全二叉树的一种特例，并且完全二叉树与同高度的满二叉树的对应结点有统一编号。
- 非空完全二叉树的特点：
    - 叶子结点只可能在最下两层出现
    - 对于最大层次的结点，都依次排列在该层最左边的位置上
    - 若有度为1的结点，只可能有一个，且该结点只有左孩子
    - 按层编号是，一旦出现编号为i的结点是叶子结点或只有左孩子，则编号大于i的结点均为叶子结点
    - 当结点总数n为奇数时，n<sub>1</sub>=0，当结点总数为偶数时，n<sub>1</sub>=1



### 2.2 二叉树的性质


## 三、二叉树的存储结构

## 四、二叉树的基本运算及其实现

## 五、二叉树的遍历

## 六、二叉树的构造

## 七、线索二叉树

## 八、哈夫曼树

## 九、用并查集求解等价问题
