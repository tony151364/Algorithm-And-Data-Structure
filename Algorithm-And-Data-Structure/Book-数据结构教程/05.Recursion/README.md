## 一、什么是递归

### 1.概念
* 程序调用自身的编程技巧
* 它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题（子问题）来求解

### 2.构成递归的条件
* 子问题须与原始问题做同样的事，且更简单
* 有一个递归出口
* 理论上，递归都可以化为迭代处理，recursion -> iteration

## 二、练习题

### 1.斐波那契数列
* 斐波那契数列又称为“兔子数列”：0,1,1,2,3,5,8,13,21,34,55....
- 定义
    * F(0) = 0, F(1) = 1
    * F(n) = F(n-1) + F(n-2), n>=2的整数
```java
public static int F(int n) {
    if (n == 0)
        return 0;
    else if(n == 1 || n == 2)
        return 1;
    else
        return F(n-1) + F(n-2);
}

```
* 这形式有个缺点——存在大量的重复运算，导致时间复杂度为2<sup>n</sup>，F(100)时程序可能就运行不了了
* 下面的两种形式可以解决这个问题

```C++
// Hanoi求解
void Hanoi(int n,char x,char y, char z){
	if(n==1)
		printf("将第%d个圆盘从%c移动到%c\n",n,x,z);
	else{
		Hanoi(n-1,x,z,y);
		printf("将第%d个圆盘从%c移动到%c\n",n,x,z);
		Hanoi(n-1,y,x,z);
	}
}

int main(void){
	int n;
	char a='X',b='Y',c='Z';
	printf("输入求解的层数："); 
	scanf("%d",&n);
	Hanoi(n,a,b,c);
	return 0;
}

```

```C++
/*递归（recursion）
	调用自身称为直接递归（direct recursion)
	
	间接递归（indirect recursion）：若过程或函数p调用过程或函数q，而q又调用p，称为间接递归（indirect recursion）
	
	任何间接递归都可以转化为直接递归
	
	尾递归（tail recursion）：一个递归过程或者递归函数中的递归调用语句是最后一条执行语句，则称这种递归调用为尾递归。 
	*/
	
// 求n！的递归函数,这个递归即是直接递归，又属于尾递归 
int fun (int n)
{
	if(n==1)
		return (1);
	else
		return (fun(n-1)*n);
} 
```

```
递归模型：
if(n==1) 
	return f(n）= 1;
else
	return f(n)*f(n-1);
第一个式子给出终止条件，称为递归出口；
第二个式子给出f(n)与f(n-1)的关系，称为递归体；
递归相当于数学归纳法的证明；


递归实现原理:
递归是函数嵌套调用的一种特殊情况，即它调用自身代码
，由于每次调用，它的参数和局部变量均不同，因而
也就保证了各个复制件的独立性。

实现步骤；
1.分解过程:将大问题分解为小问题，知道遇到递归出口为止。 
2.求值过程：已知“小问题”，计算“大问题”。 


内部实现：
并非每次调用真的复制一个复制件放到内存中，而是采用代码共享的方式，
也就是说它们都是调用同一个函数的代码，而系统为每一次调用开辟一组存储单元（栈），
用来存放本次调用的返回地址以及被中断的函数的参量值。以栈的形式存放，
每调用一次进栈一次，当返回时执行出栈操作，把当前栈顶保留的值送回相应
的参量中恢复，并按栈顶中的返回地址，从断点继续执行。 

1.每递归一次，就进栈一次，进栈次数称为递归深度，n越大递归深度越深。
2.返回时全部执行完栈为空（废话）。 

```
## 二、栈与递归




## 三、递归算法设计

### 1.带有备忘录的递归算法

* 递归一般都是自顶向下的，因此也称为：带有备忘录的自顶向下法
* 也称为剪枝，原理就是建立一个字典或，通过字典的值(value)来避免重复运算。即拿空间换时间


## 参考：1.https://zhuanlan.zhihu.com/p/78220312
