# 小灰的算法之旅

## 第一章 算法概述




### 1.1 算法和数据结构



#### 1.1.1 衡量算法的标准  
* 时间复杂度  
* 空间复杂度  


#### 1.1.2 数据结构
* 数据的组织、管理和存储格式，目的是为了高效地访问和修改数据


#### 1.1.3数据结构组成方式  

##### 1.线性结构  
* 数组、链表以及由它们衍生出来的栈、队列、哈希表
    
##### 2.树  
* 二叉树，以及由其延伸出的二叉堆等
  
##### 3.图  

##### 4.其他数据结构  
* 跳表、哈希链表、位图等  

有了数据结构这个舞台，算法才可以尽情舞蹈  



### 1.2 时间复杂度


#### 1.2.1 算法的好与坏
* 受运行环境和输入规模的影响，代码的绝对执行时间是无法估计的，但可以预估代码的基本执行次数  


#### 1.2.2 基本执行次数  
* 设T(n)为程序基本操作执行次数的函数（也可以认为是程序的相对执行时间的函数），n为问题规模

##### 1. T(n) = 3n ,执行次数是线性
```java

void eat1(int n){
    for(int i=0; i<n; i++){
        System.out.println("等待一分钟");
        System.out.println("等待一分钟");
        System.out.println("吃1cm 面包");
    }
}
```

#####  2. T(n) = 5 logn，对数阶
```java

void eat2(int n){
    for(int i=1; i<n; i/=2){
        System.out.println("等待一分钟");
        System.out.println("等待一分钟");
        System.out.println("等待一分钟");
        System.out.println("等待一分钟");
        System.out.println("吃一半面包");
    }
}

```

##### 3. T(n) = 2，常数阶

##### 4. T(n) = 0.5n<sup>2</sup> + 0.5n，执行次数是用多项式计算的

```java

void eat4(int n){
    for(int i=1; i<n; i/=2){
        for(int j=0; j<1; j++){
            System.out.println("等待一分钟");
        }
        System.out.println("吃一半面包");
    }
}

```


#### 1.2.3渐近时间复杂度  

##### 0.概念（难点）
* 若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度
    
    理解：
    * 时间复杂度就是程序的相对执行时间函数
    * 渐进时间复杂度就是把T(n)简化为一个数量级，这个数量级可以是n、n<sup>2</sup>、n<sup>3</sup>; 
    * O 也意味着T(n) 与 f(n) 是同量级
    * O(f(n))是T(n)的渐进时间复杂度，T(n)是最原始的时间复杂度，f(n)是优化后的时间复杂度，即渐进时间复杂度
    * T(n) = 5 n<sup>2</sup>    ---->     T(n) = O(f(n)) = O(n<sup>2</sup>)

##### 1.推导时间复杂度
* 如果运行时间是常数量级，则用常数1表示 
* 只保留时间函数中的最高阶项 
* 如果最高阶项存在，则省去最高阶项前面的系数


#### 1.2.4 时间复杂度的大小比较

##### 1.比较
* O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!)
* 常数阶O(1)、线性阶O(n)、平方阶O(n<sup>2</sup>))、立方阶O(n<sup>3</sup>)、对数阶O(logn)、指数阶O(2<sup>n</sup>)

##### 2.分类
* 多项式时间复杂度(polynomial time complexity)
    * O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>)
* 指数时间复杂度(exponential time complexity)
*   O(2<sup>n</sup>) < O(n!)

##### 3.NP问题
* 一个问题目前可以用多项式时间复杂度解决，称为P问题
* 一个问题目前只能用指数时间复杂度解决，称为NP问题
* NP问题转换为P问题，是计算机科学的一个难题



### 1.3 空间复杂度 


#### 1.3.1 什么是空间复杂度
* 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用了大O表示法
* 程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，f(n)为算法所占存储空间的函数
* 例子：以空间换时间


#### 1.3.2 空间复杂度的计算

常见的几种情况:

##### 1.常量空间
* 算法的存储空间固定、与输入规模无关，空间复杂度记为O(1)
```java
void fun1(int n){
    int var = 3;
}
```

##### 2.线性空间
* 当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)。

```java
void fun2(int n){
    int[] array = new int[n];
}
```

##### 3.二维空间
* 分配一个二维数组，)O(n<sup>2</sup>)

```java
void fun3(int n){
    int[][] matrix = new int[n][n];
}
```

##### 4.递归空间
* 虽然递归代码没有显示声明变量或集合，但计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈”
* “方法调用栈”包括进栈和出栈连个行为
* 当进入一个新方法是，执行入栈操作，把调用的方法和参数压入栈中；
* 当方法返回时，执行出栈操作，把调用的方法和参数从栈中弹出
* 纯粹的递归操作的空间复杂度也是线性的，其空间复杂度与递归深度成正比O(n)

```java
// 计算阶乘

void fun4(int n){
    if(n <= 1){  // 递归出口(递归结束条件)
        return 1;  // 方法开始出栈
    }else：
        return n * fun4(n-1);  // 压栈
}
```


#### 1.3.3 时间与空间的取舍
* 因为资源有限，评估时空复杂度是为了节省资源、提高效率。
* 时间换空间、空间换空间，很多时候二者不可兼得
* 绝大多数时候，渐渐复杂度更重要


### 1.4 小结
* 什么是算法？
* 什么是数据结构？
* 什么是时空复杂度？
