

### 常数操作
- 两个数相加。无论两个数多复杂，计算时间是一样的。
- 数组寻址。数组在内存可以理解为连续地址，所以arr[1]和arr[2000000]的时间是一样的

# 第1章 绪论
## 1.1 什么是数据结构

### 1.1.3 存储结构
- 顺序存储结构：数组
- 链式存储结构：链表
- 索引结构：在存储数据元素信息的同时建立附加的索引表
- 哈希(或散列)存储结构：C++的map、Python的字典

## 1.3 算法分析
- 算法分析就是分析算法占用计算机资源的多少

### 1.3.1 时间复杂度
- 一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的。下面的①、③、⑤和⑥就是原操作
```C++
void fun(int a[], int n)
{
	int i;  // ①
	for(i = 0; i < n; i++)  // ②
		a[i] = 2 * i;  // ③
	for (i = 0; i < n; i++)  // ④
		printf("%d", a[i]);  // ⑤
	printf("\n");  // ⑥
}
```
#### 2.算法事件复杂度分析
##### 3）简化的算法事件复杂度分析
- 另一种简化的算法事件复杂度分析方法仅仅考虑算法中的基本操作。**所谓基本操作是指算法中最深层循环内的原操作**

- 【例 1.7】分析以下算法的时间复杂度
```C++
void func(int n)
{
	int i = 0, s = 0;

	while (s < n)
	{
		i++;  // 基本操作
		s = s + i;  // 基本操作
	}0
}

// O(n) = 根号n
```

#### 3.算法的最好、最坏和平均时间复杂度分析
- 【例 1.8】以下算法用于求含n个整数元素的序列中前i(1 <= i <= n)个元素的最大值，分析该算法的最好、最坏和平均时间复杂度。
```C++
void func(int n)
{
	int j, max = a[0];
	for (j = 1; j <= i-1; j++)
		if (a[j] > max) max = a[j]
	return max;
}

// 最好：O(1) 
// 最坏：O(n) 
// 平均：O(n) 
```

#### 4.递归算法时间复杂度分析
- 【例 1.9】有以下算法
```C++
void fun(int a[], int n, int k)
{
	int i;
	if (k == n - 1)
	{
		for (i = 0; i < n; i++)
			printf("%d\n", a[i]);
	}
	else
	{
		for (i = k; i < n; i++)
			a[i] = a[i] + i * i;
		fun(a, n, k + 1);
	}
}
// 时间复杂度为 O(n^2)
```
### 1.3.2 空间复杂度
- 【例 1.11】对于例1.9的算法，分析调用语句func(a, n, 0)的空间复杂度
```C++
// 空间复杂度O(n)
```